#+title: Test
#+property: header-args :session test

Load a pre-trained model and generate some GeoTiffs with it

* Imports
#+begin_src jupyter-python
import os
import random

import numpy as np
from osgeo import gdal

import matplotlib as mpl
import matplotlib.pyplot as plt

import torch
import torch.nn as nn
import torchvision.transforms as transforms

from networks import Generator
from tools import random_bbox, mask_image
from blend import blend_images

#+End_src

#+RESULTS:

* Settings

TODO use TOML

#+begin_src jupyter-python
config = {
    'dataset_name': "../Testing Data/NPC_cubic.tif",
    'checkpoint_save_path': "out",
    'resume': 0,
    'batch_size': 90,
    'image_shape': [256, 256, 1],
    'mask_shape': [128, 128],
    'mask_batch_same': True,
    'max_delta_shape': [32, 32],
    'margin': [0, 0],
    'discounted_mask': True,
    'spatial_discounting_gamma': 0.9,
    'random_crop': True,
    'mask_type': "hole", # hole | mosaic
    'mosaic_unit_size': 12,

    # Training parameters
    'expname': "benchmark",
    'cuda': False,
    'n_cpu': 16,
    'lr': 0.0001,
    'beta1': 0.5,
    'beta2': 0.9,
    'n_critic': 5,
    'epochs': 1000,
    'print_iter': 1,
    'viz_iter': 10,
    'viz_max_out': 12,
    'snapshot_save_iter': 50,
    'seed': 6747,

    # Loss weight
    'coarse_l1_alpha': 1.2,
    'l1_loss_alpha': 1.2,
    'ae_loss_alpha': 1.2,
    'global_wgan_loss_alpha': 1.0,
    'gan_loss_alpha': 0.001,
    'wgan_gp_lambda': 10,

    # Network Parameters
    'input_dim': 1,
    'ngf': 32,
    'ndf': 64
}
#+end_src

#+RESULTS:

* Tile Dataset
#+begin_src jupyter-python
test = None

def tile(dataset, kernel_size):

    dem = gdal.Open(dataset)

    crs = dem.GetProjection()
    geo_transform = dem.GetGeoTransform()

    image = np.array(dem.ReadAsArray())

    img_height, img_width = image.shape
    tile_height, tile_width = kernel_size

    # If cant divide perfectly
    if (img_height % tile_height != 0 or img_width % tile_width != 0):
        new_height = img_height - (img_height % tile_height)
        new_width = img_width - (img_width % tile_width)

        image = image[:new_height, :new_width]

    tiles_high = img_height // tile_height
    tiles_wide = img_width // tile_width

    tiled_array = image.reshape(tiles_high,
                                tile_height,
                                tiles_wide,
                                tile_width )

    tiled_array = tiled_array.swapaxes(1, 2)

    tiled_array = tiled_array.reshape(tiles_high * tiles_wide, tile_height, tile_width)

    # GC should get this, but just to be safe
    dem = None

    return tiled_array, crs, geo_transform

#+end_src

#+RESULTS:

* Image Transformations
#+begin_src jupyter-python
# Normalise data to between 0<->1
def normalise(tensor):
    tensor = (tensor - torch.min(tensor)) / (torch.max(tensor) - torch.min(tensor))

    return tensor

# Return data from -1<->1 normalisation to original state
def denormalize(tensor, max, min):
    arr = tensor.cpu().detach().numpy()

    arr = np.squeeze(arr)
    arr = (arr * 0.5) + 0.5
    arr = (arr * (max - min)) + min

    return arr

# Return data from -1<->1 normalisation to 0<->1 normalisation
# Used as poisson blending requires the DEM data to be 0<->1 but the inpainted DEM is returened -1<->1
def partial_dn(tensor):

    arr = tensor.cpu().detach().numpy()

    arr = np.squeeze(arr)
    arr = (arr * 0.5) + 0.5

    return arr

# Transforms applied to each tile
transforms_ = [
    transforms.ToTensor(),
    transforms.Lambda(normalise),
    transforms.Normalize((0.5), (0.5))
]
#+end_src

#+RESULTS:

* Setup
** Seed

Can probably get rid of this, no training is happening
#+begin_src jupyter-python
seed = config["seed"]
random.seed(seed)
torch.manual_seed(seed)
#+end_src

#+RESULTS:
: <torch._C.Generator at 0x7fdbd249f1f0>

** Get Tile
#+begin_src jupyter-python
tiled, crs, geo_transform = tile(config["dataset_name"], (256, 256))
#+end_src

#+RESULTS:

* Infill

Not the most efficient way of doing things but since individual DEM files are (probably) much larger than the tiles the network is trained on.
Also a lot of data (annoyingly) seems to be basic slopes that arent very interesting.
 - There maybe is something to be said for trying to find high res (5m) DEMs with consistently complex terrain.

** Workflow
 - Manually iterate through tiles until an interesting tile is found
 - Generate infilled DEM
 - If it is either really good or really shit save to file as it will be good for the report.

** Select Tile

#+begin_src jupyter-python
print(len(tiled))
#+end_src

#+RESULTS:
: 49

#+begin_src jupyter-python
tile_n = 0

dem = tiled[tile_n]

plt.imshow(dem, cmap=plt.cm.terrain)
plt.colorbar()
#+end_src

#+RESULTS:
:RESULTS:
: <matplotlib.colorbar.Colorbar at 0x7fd99f54bd60>
[[file:./.ob-jupyter/2e5f50cb1978161235998340daa74934e315ac00.png]]
:END:

** Transform

*** Infill
#+begin_src jupyter-python

#### Transforms

img_min = np.amin(dem)
img_max = np.amax(dem)

transform = transforms.Compose(transforms_)
ground_truth = transform(dem)

#### Infill voids

# Remember (start_x, start_y, size_x, size_y)
bboxes = torch.tensor([(64, 64, 128, 128)], dtype=torch.int64)
x, mask = mask_image(ground_truth, bboxes, config, train=False)

checkpoint_path = "/home/struan/Development/Inpaint/Final Network/out2/saved_models/gen_00001000.pt"

# TODO dont need to store the inpainted result anymore
inpainted_result = None
x2 = None

with torch.no_grad():
    netG = Generator(config, config["cuda"])
    netG.load_state_dict(torch.load(checkpoint_path))

    x1, x2 = netG(x, mask)
    inpainted_result = x2 * mask + x * (1. - mask)

#### De-normalize
inpainted_result_dn = denormalize(inpainted_result, img_max, img_min)
ground_truth_dn = denormalize(ground_truth, img_max, img_min)

#### Show Result

plt.imshow(inpainted_result_dn, cmap=plt.cm.terrain)
plt.colorbar()
#+end_src

#+RESULTS:
:RESULTS:
: <matplotlib.colorbar.Colorbar at 0x7fd99f7a5ab0>
[[file:./.ob-jupyter/d42f0854b7cc774e57e8dc3b92c800067ad03367.png]]
:END:

** Poisson Blending
#+begin_src jupyter-python
mask = mask.cpu().detach().numpy()
mask = np.squeeze(mask)

infill = partial_dn(x2)
gt = partial_dn(ground_truth)

blended = blend_images(infill, gt, mask)

blended = (blended * (img_max - img_min)) + img_min
#+end_src

#+RESULTS:

#+begin_src jupyter-python
plt.figure(figsize=(15,15))
plt.subplot(1,3,1)
plt.imshow(ground_truth_dn, cmap='terrain')
plt.title("Ground Truth")
plt.subplot(1,3,2)
plt.imshow(inpainted_result_dn, cmap='terrain')
plt.title("Inpainted Result")
plt.subplot(1,3,3)
plt.imshow(blended, cmap='terrain')
plt.title("Poisson Blended")
plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/f49ce07c8b5bcb2f689d883eb9e7cf4ae3c4a7c5.png]]

** Save

#+begin_src jupyter-python
if not os.path.exists('test_results'):
    os.makedirs('test_results')

def write_geotiff(filename, arr):

    driver = gdal.GetDriverByName("GTiff")
    out_ds = driver.Create(filename, arr.shape[1], arr.shape[0], 1, gdal.GDT_Float32)
    out_ds.SetProjection(crs)

    # Get properties from input DEM
    upper_left, pixel_width, rotation, upper_right, rotation, pixel_height = geo_transform

    # Calculate tile coordinates
    upper_left += (tile_n + 1) * 256
    upper_right += (tile_n + 1) * 256

    # Set Geo-transform
    out_ds.SetGeoTransform((upper_left, pixel_width, rotation, upper_right, rotation, pixel_height))

    band = out_ds.GetRasterBand(1)
    band.WriteArray(arr)
    band.FlushCache()
    band.ComputeStatistics(False)

write_geotiff(f'test_results/{tile_n}_inpaint_poisson.tif', blended)
write_geotiff(f'test_results/{tile_n}_inpaint.tif', inpainted_result_dn)
write_geotiff(f'test_results/{tile_n}_gt.tif', ground_truth_dn)
#+end_src

#+RESULTS:
:RESULTS:
# [goto error]
#+begin_example
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
Cell In[30], line 25
     22     band.FlushCache()
     23     band.ComputeStatistics(False)
---> 25 write_geotiff(f'test_results/{tile_n}_inpaint.tif', inpainted_result)
     26 write_geotiff(f'test_results/{tile_n}_gt.tif', ground_truth)

Cell In[30], line 21, in write_geotiff(filename, arr)
     18 out_ds.SetGeoTransform((upper_left, pixel_width, rotation, upper_right, rotation, pixel_height))
     20 band = out_ds.GetRasterBand(1)
---> 21 band.WriteArray(arr)
     22 band.FlushCache()
     23 band.ComputeStatistics(False)

File /usr/lib/python3.10/site-packages/osgeo/gdal.py:4163, in Band.WriteArray(self, array, xoff, yoff, resample_alg, callback, callback_data)
   4157 def WriteArray(self, array, xoff=0, yoff=0,
   4158                resample_alg=gdalconst.GRIORA_NearestNeighbour,
   4159                callback=None,
   4160                callback_data=None):
   4161     from osgeo import gdal_array
-> 4163     return gdal_array.BandWriteArray(self, array, xoff, yoff,
   4164                                       resample_alg=resample_alg,
   4165                                       callback=callback,
   4166                                       callback_data=callback_data)

File /usr/lib/python3.10/site-packages/osgeo/gdal_array.py:468, in BandWriteArray(band, array, xoff, yoff, resample_alg, callback, callback_data)
    464 """Pure python implementation of writing a chunk of a GDAL file
    465 from a numpy array.  Used by the gdal.Band.WriteArray method."""
    467 if array is None or len(array.shape) != 2:
--> 468     raise ValueError("expected array of dim 2")
    470 xsize = array.shape[1]
    471 ysize = array.shape[0]

ValueError: expected array of dim 2
#+end_example
:END:
